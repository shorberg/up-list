<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Reliable Superstore BDC Online Up List</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <style>
    body { font-family: Arial, sans-serif; background:#f6f8fb; margin:0; padding:20px; }
    h1 { margin:0 0 8px; }
    .bar { margin:12px 0; display:flex; gap:8px; flex-wrap:wrap; }
    input { padding:6px 10px; height:36px; border:1px solid #ccc; border-radius:8px; }
    button { padding:6px 12px; height:36px; border:1px solid #ccc; border-radius:8px; background:#fff; cursor:pointer; }
    button.primary { background:#2f67ff; color:#fff; border-color:#2f67ff; }
    table { width:100%; border-collapse:collapse; background:#fff; margin-top:12px; }
    th, td { border:1px solid #ddd; padding:8px; text-align:left; vertical-align:middle; }
    thead th { background:#0f172a; color:#fff; }
    td.center { text-align:center; }
    .blackX { color:black; font-weight:bold; }
    .redX { color:red; font-weight:bold; }
    .muted { color:#5b6b7a; }
  </style>
</head>
<body>
  <h1>Reliable Superstore BDC Online Up List</h1>
  <div class="muted"><span id="today"></span> • <span id="clock"></span></div>

  <div class="bar">
    <input id="nameInput" type="text" placeholder="Add team member name" />
    <button class="primary" id="addBtn">Add</button>
    <button id="nextBtn">Next Lead</button>
    <button id="resetBtn">Reset</button>
  </div>

  <table>
    <thead>
      <tr>
        <th style="width:70px;">Order</th>
        <th style="width:220px;">Name</th>
        <th style="width:70px;">Up</th>
        <th style="width:90px;">Leads</th>
        <th style="width:120px;">Last Lead</th>
        <th style="width:120px;">Makeups</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>

<script>
  // === CONFIG ===
  const SUPABASE_URL = "https://imfzlhudhljathvkgkqf.supabase.co";
  const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImltZnpsaHVkaGxqYXRodmtna3FmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc4MDAxMDUsImV4cCI6MjA3MzM3NjEwNX0.Bb-SUJMWfzVMHkdYuAgAD31wExcLuNazss6AJ11Z_VQ";
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

  const tbody = document.getElementById("tbody");
  const nameInput = document.getElementById("nameInput");

  // Live clock
  function tick(){
    const d = new Date();
    document.getElementById("today").textContent =
      d.toLocaleDateString(undefined,{weekday:'long',year:'numeric',month:'long',day:'numeric'});
    document.getElementById("clock").textContent =
      d.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit',second:'2-digit'});
  }
  setInterval(tick, 1000); tick();

  // ------- DB helpers -------
  async function fetchPeople() {
    const { data, error } = await supabase
      .from("people")
      .select("*")
      .order("order", { ascending: true });
    if (error) { console.error("fetchPeople error:", error); return []; }
    return data || [];
  }

  async function fetchOpenMakeups() {
    const { data, error } = await supabase
      .from("makeups")
      .select("id, person_id, created_at")
      .order("created_at", { ascending: true });
    if (error) { console.error("fetchOpenMakeups error:", error); return []; }
    return data || [];
  }

  // Count red Xs by person_id from makeup rows
  function buildMakeupCountMap(makeups) {
    const map = new Map();
    for (const m of makeups) {
      map.set(m.person_id, (map.get(m.person_id) || 0) + 1);
    }
    return map;
  }

  // ------- UI render -------
  function fmtTime(ts) {
    if (!ts) return "";
    const d = new Date(ts);
    if (isNaN(d.getTime())) return ts; // keep as-is if not ISO
    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  }

  function renderTable(people, muMap) {
    tbody.innerHTML = "";
    for (const p of people) {
      const tr = document.createElement("tr");
      const muCount = muMap.get(p.id) || 0;
      const upCell = p.is_up ? '<span class="blackX">X</span>' : "";
      const red = muCount > 0 ? `<span class="redX">${"X".repeat(muCount)}</span>` : "";

      tr.innerHTML = `
        <td>${p.order}</td>
        <td>${p.name}</td>
        <td class="center">${upCell}</td>
        <td>${p.leads || 0}</td>
        <td>${fmtTime(p.last_served)}</td>
        <td class="center">${red}</td>
        <td>
          <button onclick="onNeedMakeup('${p.id}')">Need Makeup</button>
          <button onclick="onMoveXHere('${p.id}')">Move X Here</button>
          <button onclick="onRemove('${p.id}')">Remove</button>
        </td>
      `;
      tbody.appendChild(tr);
    }
  }

  async function refresh() {
    const [people, makeups] = await Promise.all([fetchPeople(), fetchOpenMakeups()]);
    const muMap = buildMakeupCountMap(makeups);
    renderTable(people, muMap);
  }

  // ------- Actions -------
  async function addPerson() {
    const raw = nameInput.value.trim();
    if (!raw) return;
    const fixed = raw.toLowerCase().replace(/\b\w/g, m => m.toUpperCase());

    const people = await fetchPeople();
    const nextOrder = people.length ? Math.max(...people.map(p => p.order || 0)) + 1 : 1;

    // If nobody is up yet, first added gets the black X
    const anyUp = people.some(p => p.is_up === true);

    const { error } = await supabase.from("people").insert([{
      name: fixed,
      status: "Here",
      is_up: !anyUp && people.length === 0, // first person gets X
      order: nextOrder,
      leads: 0,
      last_served: null
    }]);

    if (error) { console.error("addPerson error:", error); }
    nameInput.value = "";
    refresh();
  }

  async function onNeedMakeup(personId) {
    // Decrement their leads by 1 (but not below 0), then add a makeup row
    const { data: person, error: selErr } = await supabase
      .from("people").select("leads").eq("id", personId).single();
    if (selErr) { console.error("needMakeup select error:", selErr); return; }

    const newLeads = Math.max(0, (person?.leads || 0) - 1);
    const u1 = await supabase.from("people").update({ leads: newLeads }).eq("id", personId);
    if (u1.error) { console.error("needMakeup update error:", u1.error); return; }

    const ins = await supabase.from("makeups").insert([{ person_id: personId }]);
    if (ins.error) { console.error("makeups insert error:", ins.error); }
    refresh();
  }

  async function onMoveXHere(personId) {
    // Clear existing X, then set on requested person
    const u1 = await supabase.from("people").update({ is_up: false }).not("id", "is", null);
    if (u1.error) { console.error("clear X error:", u1.error); }
    const u2 = await supabase.from("people").update({ is_up: true }).eq("id", personId);
    if (u2.error) { console.error("set X error:", u2.error); }
    refresh();
  }

  async function onRemove(personId) {
    // Remove person and their queued makeups
    const d1 = await supabase.from("makeups").delete().eq("person_id", personId);
    if (d1.error) console.error("delete makeups error:", d1.error);
    const d2 = await supabase.from("people").delete().eq("id", personId);
    if (d2.error) console.error("delete person error:", d2.error);
    refresh();
  }

  async function nextLead() {
    const [people, makeups] = await Promise.all([fetchPeople(), fetchOpenMakeups()]);
    if (people.length === 0) return;

    // 1) Serve makeups first (strict FIFO by created_at)
    if (makeups.length > 0) {
      const mu = makeups[0]; // oldest
      const give = await supabase.from("people").update({
        leads: (people.find(p => p.id === mu.person_id)?.leads || 0) + 1,
        last_served: new Date().toISOString()
      }).eq("id", mu.person_id);
      if (give.error) { console.error("makeup serve error:", give.error); return; }

      const del = await supabase.from("makeups").delete().eq("id", mu.id);
      if (del.error) { console.error("makeup delete error:", del.error); }
      // Do NOT move black X when serving makeup
      return refresh();
    }

    // 2) No makeups → normal rotation
    let current = people.find(p => p.is_up);
    if (!current) {
      // set first person as up and stop; next click will give them a lead
      const setFirst = await supabase.from("people").update({ is_up: true }).eq("id", people[0].id);
      if (setFirst.error) console.error("set first up error:", setFirst.error);
      return refresh();
    }

    // Give current their lead and timestamp, clear X
    const upIdx = people.findIndex(p => p.id === current.id);
    const u1 = await supabase.from("people").update({
      leads: (current.leads || 0) + 1,
      last_served: new Date().toISOString(),
      is_up: false
    }).eq("id", current.id);
    if (u1.error) { console.error("update current error:", u1.error); return; }

    // Move X to next by order (wrap)
    const nextIdx = (upIdx + 1) % people.length;
    const u2 = await supabase.from("people").update({ is_up: true }).eq("id", people[nextIdx].id);
    if (u2.error) { console.error("update next error:", u2.error); }
    refresh();
  }

  async function resetAll() {
    // Clear all counts, last_served, X state; clear all makeups
    const u = await supabase.from("people")
      .update({ leads: 0, last_served: null, is_up: false })
      .not("id","is", null);
    if (u.error) console.error("reset people error:", u.error);

    const d = await supabase.from("makeups").delete().neq("id", "00000000-0000-0000-0000-000000000000");
    if (d.error) console.error("reset makeups error:", d.error);

    refresh();
  }

  // ------- Wire up -------
  document.getElementById("addBtn").onclick = addPerson;
  document.getElementById("nextBtn").onclick = nextLead;
  document.getElementById("resetBtn").onclick = resetAll;
  nameInput.addEventListener("keydown", e => { if (e.key === "Enter") addPerson(); });

  // Initial load + light polling to stay in sync across browsers
  refresh();
  setInterval(refresh, 5000);
</script>
</body>
</html>
